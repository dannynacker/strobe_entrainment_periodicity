% Define parameters
T = 300;  % total time (secs)
osig = 'Poisson';  % onset time
relo = false;  % relative onset time with Gamma jitter?
ondur = 'hcycle';  % cycle "on" duration
dsig = 'fixed';  % on-duration
rmode = 3;  % regularisation mode
fs = 2000;  % Hz - this is apparently what the device expects
dfac = 5; %spectral power display frequency cutoff factor 
condition = 'Poisson';

% Define desired frequencies
desired_frequencies = [8:0.1:12.0, 14]; % Range from 8.0 to 12.0 with a step of 0.1, plus 14

% Initialize a cell array to store results
results = {};

for i = 1:length(desired_frequencies)
    target_Fe = desired_frequencies(i);
    F = target_Fe; % Start with the target effective frequency as initial frequency
    
    % Initialize variables
    tolerance = 0.01; % Tolerance for effective frequency match
    max_iterations = 10000; % Maximum number of iterations to find the matching Fe
    iteration = 0;
    best_signal = [];
    best_Fe = 0;
    best_F = F;
    
    while iteration < max_iterations
        [signal] = gen_strobe_aperiodic(F, T, osig, relo, ondur, dsig, rmode);
        
        % Regularize the strobe signal
        signal = regularise_strobe(signal, rmode);
        
        % Calculate the effective frequency
        Fe = calculate_effective_frequency(F, T, osig, relo, ondur, dsig, rmode);
        
        if abs(Fe - target_Fe) <= tolerance
            best_signal = signal;
            best_Fe = Fe;
            best_F = F;
            break;
        end
        
        % Adjust the frequency based on the effective frequency
        if Fe < target_Fe
            F = F + 0.1;
        else
            F = F - 0.1;
        end
        
        iteration = iteration + 1;
        
        % Print progress for this frequency
        if mod(iteration, 100) == 0
            fprintf('Frequency %0.1f: iteration %d, current F = %0.1f, current Fe = %0.3f\n', target_Fe, iteration, F, Fe);
        end
    end
    
    % Ensure the best_signal is properly formatted
    if size(best_signal, 2) ~= 2
        error('The signal generated by gen_strobe_aperiodic is not in the expected format.');
    end
    
    % Process the signal to generate samples
    [samples, ts] = sample_strobe(best_signal, fs, T);
    
    % Save the signal with Fe in the filename
    formatted_F = sprintf('%.1f', best_Fe); % Format the frequency to one decimal place
    signal_filename = sprintf('aperiodic_%s.mat', formatted_F);
    save(signal_filename, 'best_signal', 'F', 'Fe', 'samples', 'ts');
    
    % Store results in the cell array
    results = [results; {best_F, best_Fe, signal_filename}];
    
    % Print progress for this desired frequency
    fprintf('Completed processing for target frequency %0.1f Hz. Best Fe = %0.3f\n', target_Fe, best_Fe);
end

% Convert cell array to table and write to Excel
results_table = cell2table(results, 'VariableNames', {'F', 'Fe', 'Signal_Filename'});
writetable(results_table, 'simulation_results.xlsx');

fprintf('Simulations completed and results saved.\n');

function [samples, ts] = sample_strobe(signal, fs, T)
    % Sample the signal at frequency fs, over a time segment of length T
    ndt = T * fs; % number of samples - must be an integer
    assert(ceil(ndt) == ndt, 'Number of samples must be an integer (check total time and sampling frequency)');
    ndt1 = ndt + 1;

    assert(all(signal(:,1) >= 0), 'On times must be nonnegative');
    assert(all(signal(:,2) >  0), 'Durations must be positive');

    ts = (0:ndt)' / fs;        % sample time stamps
    samples = zeros(ndt1, 1); % time series (binary)

    % Quantise to sample frequency
    son = round(signal(:,1) * fs) + 1; % on sample numbers
    sdur = ceil(signal(:,2) * fs);    % numbers of on samples (duration)
    soff = son + sdur - 1;              % off sample numbers

    for e = 1:length(son)
        if son(e) > ndt1, continue; end % on time out of range - ignore
        if soff(e) > ndt1, soff(e) = ndt1; end % ensure on till end of time series
        samples(son(e):soff(e)) = 1;           % turn on for duration
    end
end

function osignal = regularise_strobe(signal, rmode)
    % Regularise the strobe sequence 'signal' by dealing with overlaps.
    % NOTE: 'signal' events must be sorted!
    % Overlapping flashes are dealt with sequentially as follows:
    % rmode == 1 : merge/subsume
    % rmode == 2 : always truncate
    % rmode == 3 : ignore later flash
    % rmode == 4 : ignore earlier flash.

    assert(ismatrix(signal) && size(signal,2) == 2, 'Bad signal - must be a 2-column matrix');
    assert(isscalar(rmode) && isnumeric(rmode) && any(rmode == 1:4), 'Regularisation mode must be an integer in range 1 - 4');

    nevents = size(signal, 1);
    osignal = zeros(nevents, 2);
    e = 1;
    o = 0;

    if rmode == 1 % merge/subsume
        while e < nevents
            o = o+1;
            osignal(o,:) = signal(e,:); % copy event
            if signal(e+1,1) <= signal(e,1)+signal(e,2) % clash
                if signal(e+1,1) + signal(e+1,2) <= signal(e,1)+signal(e,2) % contained
                    % do nothing (just ignore event e+1)
                else % overlap
                    osignal(o,2) = signal(e+1,1) - signal(e,1) + signal(e+1,2);
                end
                e = e+2; % skip past event e+1
            else % no clash
                e = e+1;
            end
        end
    elseif rmode == 2 % always truncate
        while e < nevents
            o = o+1;
            osignal(o,:) = signal(e,:); % copy event
            if signal(e+1,1) <= signal(e,1)+signal(e,2) % clash
                if signal(e+1,1) + signal(e+1,2) <= signal(e,1)+signal(e,2) % contained
                    osignal(o,2) = signal(e+1,1) - signal(e,1) + signal(e+1,2);
                else % overlap
                    % do nothing (just ignore event e+1)
                end
                e = e+2; % skip past event e+1
            else % no clash
                e = e+1;
            end
        end
    elseif rmode == 3 % later event ignored
        while e < nevents
            o = o+1;
            osignal(o,:) = signal(e,:); % copy event
            if signal(e+1,1) <= signal(e,1)+signal(e,2) % clash
                % do nothing (just ignore event e+1)
                e = e+2; % skip past event e+1
            else % no clash
                e = e+1;
            end
        end
    elseif rmode == 4 % earlier event ignored
        while e < nevents
            o = o+1;
            if signal(e+1,1) <= signal(e,1)+signal(e,2) % clash
                osignal(o,:) = signal(e+1,:); % copy later event
                e = e+2; % skip past event e+1
            else % no clash
                osignal(o,:) = signal(e,:); % copy event
                e = e+1;
            end
        end
    end

    % last event
    if e == nevents % in case last event was ignored!
        o = o+1;
        osignal(o,:) = signal(nevents,:); % copy event
    end

    % truncate signal
    osignal = osignal(1:o,:);
end

function Fe = calculate_effective_frequency(F, T, osig, relo, ondur, dsig, rmode)
    % Generate the aperiodic strobe signal
    [~, Fe, ~] = gen_strobe_aperiodic(F, T, osig, relo, ondur, dsig, rmode);
end
